# 2023/3/01

# 2023/2/23
Speculative Interference Attack
The speculative interference attack transforms the secret-dependent delay into cache covert channel by reordering the victim access and comparing it with a reference memory access. The reference memory access is independent of the secret, hence the attacker can probe the secret by observing whether the victim access is before or after the reference memory access.
# 2023/2/22
Speculative Interference Attack
Pointer chasing refers to a common sequence of instructions that involves a repeated series of irregular memory access patterns that require the accessed data to determine the subsequent pointer address to be accessed, forming a serially-dependent chain of loads.

This paper specified three types of interference gadgets. In a Type 1 gadget, the resource of the interfering instructions is dependent on secret value. In a Type 2 gadget, the interfering instructions are issued at a secret-dependent time. In a Type 3 gadget, whether the interfering instructions execute at all depends on the secret.

Delay data access with MSHR
This gadget is composed of M (M is the number of MSHR) speculative loads that depend on secret. Depending on the value of the secret, the gadgets load from one cache line or M different cache lines, where the latter condition leads to all the MSHR getting occupied, which further delays the victim load.
Delay data access using non-pipelined EU
The interference target is a victim load whose address is generated by a dependent chain of instructions, denoted f. The gadget is a speculative load followed by a sequence of instructions, denoted f’, whose operand is the value returned from the load of the gadget. Both f and f’ share the same non-pipelined EU. Depending on the value of the secret, the gadget either loads the secret back or not, which further triggers the execution of f’ or not. When f’ is executing, since f and f’ share a non-pipelined EU, the execution of f is delayed.
Delay instruction fetch with RS contention
The interference gadget is a speculative secret-dependent load followed by a long sequence of arithmetic instructions whose operand is the value returned by the gadget. The sequence is long enough to fill the reservation station (RS). If the secret value triggers the execution of the gadget load, the following sequence of arithmetic instructions will occupy RS, which creates pressure on the front end and prevents the target instruction from being issued.
# 2023/2/20
Automatically characterizing Large Scale Program Behavior
Basic block is a segment of codes that get executed from the beginning to the end and has one entry and exit. It reflects the performance of a program in an interval of time. The distribution of basic blocks is a fingerprint of an interval of codes. Two different intervals with similar basic block fingerprints should have similar performance.
Basic Block Vector
BBV is a single dimensional array of which each entry is the count of entering the corresponding basic block during an interval of execution, multiplied by the number of instructions in that basic block.
Data differences
Manhattan distance is used in this paper instead of Euclidean distance because it weighs more heavily differences in each dimension.



# 2023/1/30
The speculative interference attacks contains 3 parts:
A speculative load reads secrets into the pipeline and transmits it to a bench of speculative executed instructions, called interference gadget, that may cause secret-dependent influence on microarchitectural resources.
Causing contention influences the timing of the non-speculative part of the pipeline, called interference target, which encodes the secret.
Changing the timing of the target creates a “ripple effect” that can ultimately delay the unprotected memory access. Executing the targets influences when the unprotected memory operation is issued and accesses the cache, thereby changing the cache state.
# 2023/1/27
Where we are.
Currently we are facing two major problems:
How to enable the hardware to remember the paths that have been scanned.
How to discover gadgets.
For the first question, we want to add a field to PHT to remember the path.
For the second question, we are thinking of “mimicking” the Kasper paper in a hardware fashion. This consist of:
Monitor the syscalls. How many system calls do we need to monitor to detect Spectre gadgets?
How to monitor system calls on hardware?

This section discussed how to evict and load back the enclave page cache (EPC).

5.5.1 Page eviction and the TLBs
EPC: Enclave Page Cache
EPCM: Enclave Page Cache Metadata
TCS: Thread Control Structure 
SECS: The SGX Enclave Control Structure 
SSA: State Save Area 
IPI: Inter-Processor Interrupt
AEX: Asynchronous Enclave Exit

Evict: EBLOCK - ETRACK - enclave exits - EWB
Load back: ELDU/ ELDB

5.5.2 The Version Array
VA: Version Array
Allocated by EPA instruction
5.5.3 Enclave IDs
SDM: Software Development Manual

5.5.4 Evicting an EPC	 Page
PAGEINFO: Page Information structure
PCMD: Page Crypto Metadata
SECINFO:Security Information (SECINFO)
PT: Page Type

5.5.5 Loading an Evicted Page Back into EPC
VPN: virtual page number

5.5.6 Eviction Trees


# 2023/1/26
Where we are.
# 2023/1/24
Speculative Interference

# 2023/1/23
Speculative Interference
Delay-on-Miss
Invisible speculation blocks
Cache based side channel
Contention-based side channel
MSHR & nonblocking caches

# 2023/1/19
CHEx86
CHEx86 implements capability-based addressing at the hardware-level/binary translation-level/microcode-level.
Hardware level
Translation-level
Microcode-level. In CHEx86, the microcode customization unit takes charge of the core functionality of the generation of capabilities (also monitoring syscalls). It instruments the dynamic instruction stream with appropriate capability generation, validation and free micro-ops. According to the paper, “This can be done by leveraging existing functionality and existing micro-op instructions in modern processor architectures (including ARM and x86), by simply re-routing the translation of relevant native macro-operations to the microcode RAM that hosts custom translations”.
Generation of capabilities
When a program calls a system call such as malloc, the microcode customization unit  intercepts such an event, instruments the intercepted macro-op (but at the same time indicates that the allocation is still in progress) and instantiates a new capability (by saving metadata to shadow memory). When the memory allocation is complete and the heap management function returns, the microcode customization unit intercepts the macro-op and instrument it (and copies the contents of the return value register to the base address field of the capability). 
# 2023/1/17
Perseverance is not a long race; it is many short races one after another.
# 2022/12/22
ASan paper
Shadow memory
Shadow memory is used to store metadata corresponding to each piece of application data.
Instrumentation
Valgrind (Memcheck) [21], Dr. Memory [8], Purify[13], BoundsChecker [17], Intel Parallel Inspector [15] and Discover are able to find out-of-bounds and use-after-free bugs in the heap memory with no false positives. But they cannot find out-of-bounds in the stack memory.
Mudflap [11] may detect out-of-bounds bugs in the stack but it’s unable to detect all stack buffer overflow bugs. It also has false positive reports in the C++ code.
Debug Allocators
# 2022/12/22
ASan paper
ASan uses shadow memory to record whether each byte of application memory is safe to access and uses instrumentation to check each of the application write or load.
Shadow memory
Shadow memory dictates one-eight of the virtual memory space as its shadow address. It uses scale + offset mapping. The memory addresses returned by the malloc function are aligned to 8 bytes. As for the 8 bytes, they have 9 states: the first k bytes are addressable and the remaining 8-k bytes are not. ASan encodes the application memory in the corresponding shadow memory addresses: 0 means all the 8 bytes are addressable, k(1 ≤ k ≤ 7) means that the first k bytes are addressable, any negative number means that the entire 8 bytes are not addressable.
Instrumentation
On each 8 byte memory access, ASan instruments the addresses by computing the corresponding shadow memory and checks whether the whole 8 bytes are addressable(the value is zero) and reports if not.
REST( Random Embedded Security Tokens) paper
REST stores a token (a long unique value) to blacklist memory regions. If the token is touched, REST issues a privileged exception.
